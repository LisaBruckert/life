<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of feSegmentFascicleFromConnectome</title>
  <meta name="keywords" content="feSegmentFascicleFromConnectome">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">utility</a> &gt; feSegmentFascicleFromConnectome.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for utility&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>feSegmentFascicleFromConnectome
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [fg, keepFG] = feSegmentFascicleFromConnectome(fg, rois, operation, fascicleFileName) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 Segment a fascicle from a connectome by applying a series of 'AND' and
 'NOT' operations between the connectome and a set of ROIs.

 The important aspect of this function is that it returns both the new
 fiber group AND the indices in the origianl fiber group of the fibers
 that passed all the 'and' and 'not' operations requested.

 These idices can be used to address the columns of a LiFE model (M
 matrix). This allows for subtracting entire fiber group dfined
 anatomically from a pre-existing connectome. In turns this allows for
 testing hypotheses on the improtance of an (anatomically selected)
 fascicle within the volume of white-mater comprised by the connectome.

 [fg fibersIndices] = feSegmentFascicleFromConnectome(fg, rois, operation, fascicleFileName)

 INPUTS:
   fg           - A connectome (e.g., fg = feGet(fe,'fibers acpc'))
   rois         - A cell array of rois to be used for selecting the fibers in the
                  final fascicle
   operation    - A set of logical operations to be applied to the fibers in
                 the connectome in relation to the rois. There should be one
                 operation per roi. 
   fascicleName - The name of the final fascicle. 


 OUTPUTS:
  fg            - The segmented fiber group, containing only the fibers
                  that passed all the logical operations.
  keepFG        - A vector of indices (0's and 1's) of the length of the
                  number of fibers in the input fiber group. A one
                  indicates that the fiber survived all the logical
                  operations requested. A 0 indicates that the fibers did
                  not survive some of the logical operations and it was
                  deleted from the output fiber group.


 Copyright Franco Pestilli (2013) Vistasoft Stanford University.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [fg, keepFG] = feSegmentFascicleFromConnectome(fg, rois, operation, fascicleFileName)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% Segment a fascicle from a connectome by applying a series of 'AND' and</span>
0004 <span class="comment">% 'NOT' operations between the connectome and a set of ROIs.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% The important aspect of this function is that it returns both the new</span>
0007 <span class="comment">% fiber group AND the indices in the origianl fiber group of the fibers</span>
0008 <span class="comment">% that passed all the 'and' and 'not' operations requested.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% These idices can be used to address the columns of a LiFE model (M</span>
0011 <span class="comment">% matrix). This allows for subtracting entire fiber group dfined</span>
0012 <span class="comment">% anatomically from a pre-existing connectome. In turns this allows for</span>
0013 <span class="comment">% testing hypotheses on the improtance of an (anatomically selected)</span>
0014 <span class="comment">% fascicle within the volume of white-mater comprised by the connectome.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% [fg fibersIndices] = feSegmentFascicleFromConnectome(fg, rois, operation, fascicleFileName)</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% INPUTS:</span>
0019 <span class="comment">%   fg           - A connectome (e.g., fg = feGet(fe,'fibers acpc'))</span>
0020 <span class="comment">%   rois         - A cell array of rois to be used for selecting the fibers in the</span>
0021 <span class="comment">%                  final fascicle</span>
0022 <span class="comment">%   operation    - A set of logical operations to be applied to the fibers in</span>
0023 <span class="comment">%                 the connectome in relation to the rois. There should be one</span>
0024 <span class="comment">%                 operation per roi.</span>
0025 <span class="comment">%   fascicleName - The name of the final fascicle.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% OUTPUTS:</span>
0029 <span class="comment">%  fg            - The segmented fiber group, containing only the fibers</span>
0030 <span class="comment">%                  that passed all the logical operations.</span>
0031 <span class="comment">%  keepFG        - A vector of indices (0's and 1's) of the length of the</span>
0032 <span class="comment">%                  number of fibers in the input fiber group. A one</span>
0033 <span class="comment">%                  indicates that the fiber survived all the logical</span>
0034 <span class="comment">%                  operations requested. A 0 indicates that the fibers did</span>
0035 <span class="comment">%                  not survive some of the logical operations and it was</span>
0036 <span class="comment">%                  deleted from the output fiber group.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% Copyright Franco Pestilli (2013) Vistasoft Stanford University.</span>
0040 
0041 <span class="comment">% Make sure that the inputs have one logical operation per ROI</span>
0042 <span class="keyword">if</span> ~(length(rois) == length(operation))
0043   error(<span class="string">'[%s] Please provide one logical operand (e.g., ''and'', ''not'') for each ROI...'</span>,mfilename)
0044 <span class="keyword">end</span>
0045 
0046 <span class="comment">% Read fibers, if a path was passed</span>
0047 <span class="keyword">if</span> ~isstruct(fg)
0048   fg = fgRead(fg);
0049 <span class="keyword">end</span>
0050 
0051 <span class="comment">% The following is the vector containing the indices</span>
0052 <span class="comment">% to the fibers we KEEP from the origianl fiber group</span>
0053 <span class="comment">% after all the logical operations are applied.</span>
0054 keepFG = false(length(fg.fibers),1); 
0055 
0056 <span class="comment">% The following is a cell array which will old the relative indices of the</span>
0057 <span class="comment">% fibers into each sized-down version of the fibers.</span>
0058 <span class="comment">% Each entry of the cell arry holds the indices to the fibergroup in the</span>
0059 <span class="comment">% before the current operation was applied.</span>
0060 currentFibIndices = cell(length(rois)+1,1);    
0061 currentFibIndices{1} = 1:length(keepFG);
0062 
0063 <span class="keyword">for</span> ir = 1:length(rois)
0064   <span class="comment">% Read the rois from disk if paths were passed in</span>
0065   <span class="keyword">if</span> ~isstruct(rois{ir})
0066     rois{ir} = dtiReadRoi(rois{ir});
0067   <span class="keyword">end</span>
0068   
0069   <span class="comment">% Intersect the wholebrain fiber group with &quot;AND&quot; / &quot;NOT&quot; ROIs</span>
0070   [fg, ~, keep]  = dtiIntersectFibersWithRoi([],operation{ir},[],rois{ir},fg);
0071   
0072   <span class="comment">% Select the indices fo the fibers that were deleted in the previous</span>
0073   <span class="comment">% loop. The way we address these indices depends on the type of operation.</span>
0074   <span class="comment">% For 'and' we simply use the idices in keep{ir-1}</span>
0075   <span class="comment">% For 'not' we need to flip the sign and use the indices in kee{ir-1}</span>
0076   <span class="comment">% that were se to 0.</span>
0077   <span class="comment">%</span>
0078   <span class="comment">% See help dtiIntersectFibersWithRoi.m</span>
0079   <span class="comment">% &quot;The output variables keep and keepID vectors for &quot;not&quot; option are</span>
0080   <span class="comment">% counterintuitive: they mark fibers that DO intersect the ROI and that are</span>
0081   <span class="comment">% exluded from the output FG.&quot;</span>
0082   <span class="keyword">switch</span> operation{ir}
0083     <span class="keyword">case</span> {<span class="string">'and'</span>,<span class="string">'AND'</span>,<span class="string">'and both endpoints'</span>,<span class="string">'endpoints'</span>}
0084       currentFibIndices{ir+1} = currentFibIndices{ir}(keep);
0085     <span class="keyword">case</span> {<span class="string">'not'</span>,<span class="string">'NOT'</span>}
0086       currentFibIndices{ir+1} = currentFibIndices{ir}(~keep);
0087     <span class="keyword">otherwise</span>
0088       keyboard
0089   <span class="keyword">end</span>
0090   clear keep
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% Save the indices of the fibers that survived all the operations.</span>
0094 keepFG( currentFibIndices{end} ) = true;
0095 
0096 <span class="comment">% Clean up the rest of the fields in the fiber group.</span>
0097 <span class="comment">% dtiIntersectFibersWithRoi.m does not handle other fields but the .fiber</span>
0098 <span class="comment">% one.</span>
0099 fg.pathwayInfo = [];
0100 fg.seeds       = [];
0101 fg.Q           = [];
0102 fg.params      = [];
0103 
0104 <span class="comment">% Change the fibergroup name</span>
0105 <span class="keyword">if</span> isstruct(fascicleFileName)
0106     fg.name = fascicleFileName.name;
0107 <span class="keyword">else</span>
0108     fg.name = fascicleFileName;
0109 <span class="keyword">end</span>
0110 <span class="keyword">return</span></pre></div>
<hr><address>Generated on Tue 01-Jul-2014 13:06:36 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>